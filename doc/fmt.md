## fmt 格式化输出


/*
包fmt实现了格式化的I/O，其函数类似于
与C语言的printf和scanf类似。 格式化 "动词 "来自于C语言，但是
但更简单。




	一般来说。
		%v 默认格式下的值
			当打印结构时，加号（%+v）会增加字段名。
		%#v是数值的语法表示法
		%T 表示该值的类型的语法表示。
		%% 字面百分号；不消耗任何值。

	布尔值。
		％T表示真或假
	整数。
		%b 基数2
		%c 相应的Unicode代码点所代表的字符
		%d 基数10
		%o 基数8
		%O 基数为8，前缀为0o
		%q 一个单引号的字符字面用Go语法安全地转义。
		%x基数16，小写字母为a-f
		%X 16进制，A-F为大写字母。
		%U Unicode格式。U+1234；与 "U+%04X "相同
	浮点和复数成分。
		%b无小数科学记数法，指数为2的幂。
			以strconv.FormatFloat的方式，采用'b'格式。
			例如：-123456p-78
		%E 科学记数法，例如：-1.234456e+78
		%E 科学记数法，例如：-1.234456E+78
		%f小数点，但没有指数，例如：123.456
		%F 与 %f 的同义词
		%g %e用于大指数，否则为%f。精度将在下面讨论。
		%G %E用于大指数，否则为%F
		%x 十六进制符号（十进制的两个指数幂），例如：-0x1.23abcp+20
		%X大写的十六进制符号，例如：-0X1.23ABCP+20
	字符串和字节片（用这些动词等价处理）。
		%s 字符串或片断的未解释的字节
		%q 一个双引号的字符串，用Go语法安全转义。
		%x 16进制，小写，每字节两个字符
		%X 16进制，大写字母，每字节两个字符
	分片。
		%p 第0个元素的地址，以16进制表示，前导0x
	指针。
		%p以16进制表示，带前导0x
		%b、%d、%o、%x和%X动词也适用于指针。
		格式化的值就像它是一个整数一样。

	%v的默认格式是。
		bool: %t
		int, int8等：%d
		uint, uint8等：%d，如果用%#v打印，则为%#x
		float32, complex64, etc.: %g
		字符串: %s
		chan: %p
		指针: %p
	对于复合对象，使用这些规则，递归地打印元素。
	像这样排列。
		结构。            {field0 field1 ...}
		array, slice: [elem0 elem1 ...］
		地图：map[key1:value1 key2:value2 ...]
		上面的指针： &{}, &[], &map[]

	宽度由紧挨着动词的一个可选的十进制数字指定。
	如果没有，宽度就是表示该值所需的任何内容。
	精度在宽度（可选）之后由一个句号和一个小数点指定。
	十进制数字。如果没有句号，将使用默认的精度。
	句号后面没有数字，则指定精度为零。
	例子。
		%f 默认宽度，默认精度
		%9f 宽度9，默认精度
		%.2f 默认宽度，精度为2
		%9.2f宽度为9，精度为2
		%9.f宽度为9，精度为0

	宽度和精度是以Unicode码位为单位衡量的。
	也就是符码。(这与C语言的printf不同，后者的单位总是以字节为单位。
	单位总是以字节为单位）。这两个标志中的一个或两个
	可以用字符'*'代替，使它们的值从下一个操作数（前面的）中获得。
	从下一个操作数（在要格式化的操作数之前）获得。
	它必须是int类型的。



通过www.DeepL.com/Translator（免费版）翻译

*/